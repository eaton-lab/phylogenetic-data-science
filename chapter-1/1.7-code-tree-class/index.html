
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../1.6-code-tree-traversal/">
      
      
        <link rel="next" href="../../chapter-2/2.0-modeling-evolution/">
      
      <link rel="icon" href="/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.11">
    
    
      
        <title>1.7 - Code - Tree class - Phylogenetic Data Science (IN DEVELOPMENT)</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0d440cfe.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.2505c338.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script id="__analytics">function __md_analytics(){function n(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],n("js",new Date),n("config","G-HV34HZZD5N"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){this.value&&n("event","search",{search_term:this.value})}),document$.subscribe(function(){var a=document.forms.feedback;if(void 0!==a)for(var e of a.querySelectorAll("[type=submit]"))e.addEventListener("click",function(e){e.preventDefault();var t=document.location.pathname,e=this.getAttribute("data-md-value");n("event","feedback",{page:t,data:e}),a.firstElementChild.disabled=!0;e=a.querySelector(".md-feedback__note [data-md-value='"+e+"']");e&&(e.hidden=!1)}),a.hidden=!1}),location$.subscribe(function(e){n("config","G-HV34HZZD5N",{page_path:e.pathname})})});var e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=G-HV34HZZD5N",document.getElementById("__analytics").insertAdjacentElement("afterEnd",e)}</script>

  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#the-toytree-class" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Phylogenetic Data Science (IN DEVELOPMENT)" class="md-header__button md-logo" aria-label="Phylogenetic Data Science (IN DEVELOPMENT)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Phylogenetic Data Science (IN DEVELOPMENT)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              1.7 - Code - Tree class
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
            </label>
          
        
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/eaton-lab/phylogenetic-data-science" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Phylogenetic Data Science (IN DEVELOPMENT)" class="md-nav__button md-logo" aria-label="Phylogenetic Data Science (IN DEVELOPMENT)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Phylogenetic Data Science (IN DEVELOPMENT)
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/eaton-lab/phylogenetic-data-science" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        About/Ethos
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../installation/" class="md-nav__link">
        Installation/Software
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../course/" class="md-nav__link">
        Columbia course
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          0 - Coding Bootcamp
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          0 - Coding Bootcamp
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/getting-started/" class="md-nav__link">
        Getting started
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.0-installation-conda/" class="md-nav__link">
        0.0 - Installation (conda)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.1-jupyter-and-binder/" class="md-nav__link">
        0.1 - Python Jupyter/Binder
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.2-python-types/" class="md-nav__link">
        0.2 - Python types
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.3-python-funcs/" class="md-nav__link">
        0.3 - Python functions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.4-python-classes/" class="md-nav__link">
        0.4 - Python classes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../bootcamp/0.5-python-style/" class="md-nav__link">
        0.5 - Python style
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          1 - Trees as data
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          1 - Trees as data
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.1-introduction/" class="md-nav__link">
        x.1 - Introduction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.2-tree-thinking/" class="md-nav__link">
        x.2 - Tree Thinking
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.3-visualization/" class="md-nav__link">
        x.3 - Visualization
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.4-features-of-trees/" class="md-nav__link">
        1.4 - Tree data structure
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.5-code-node-class/" class="md-nav__link">
        1.5 - Code - Node class
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.6-code-tree-traversal/" class="md-nav__link">
        1.6 - Code - Tree traversal
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          1.7 - Code - Tree class
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        1.7 - Code - Tree class
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#learning-objectives" class="md-nav__link">
    Learning objectives
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#caching-traversals" class="md-nav__link">
    Caching Traversals
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trees-versus-nodes" class="md-nav__link">
    Trees versus Nodes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree-class" class="md-nav__link">
    Tree Class
  </a>
  
    <nav class="md-nav" aria-label="Tree Class">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#indexable-class" class="md-nav__link">
    Indexable class
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-class" class="md-nav__link">
    Iterable class
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree-class-advanced" class="md-nav__link">
    Tree Class (Advanced)
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../1.6-exercises.md" class="md-nav__link">
        x.7 - Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          2 - Evolutionary models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          2 - Evolutionary models
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.0-modeling-evolution/" class="md-nav__link">
        2.0 - Modeling evolution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.1-idealized-population/" class="md-nav__link">
        2.1 - Idealized population
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.2-wright-fisher/" class="md-nav__link">
        2.2 - Wright-Fisher Process
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.3-coalescent/" class="md-nav__link">
        2.3 - The Coalescent
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.4-coalescent-simulation/" class="md-nav__link">
        2.4 - Coalescent simulation
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-2/2.x-exercises/" class="md-nav__link">
        2.x - Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          3 - Mutation Models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          3 - Mutation Models
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-3/3.x-DNA-Markov.md" class="md-nav__link">
        3.0 - Modeling Evolution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        3.x - Probabilistic and Generative Models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-3/3.2-markov-models/" class="md-nav__link">
        3.2 - Markov models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../3.x-other-models.md" class="md-nav__link">
        3.x - Other models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1-reading-list.md" class="md-nav__link">
        Reading and Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          4 - Data
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          4 - Data
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../4.1-data-formats.md" class="md-nav__link">
        x.1 - data formats
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../4.2-strings-and-matrices.md" class="md-nav__link">
        x.2 - strings, tables, and matrices
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../x.x-simulating-traits.md" class="md-nav__link">
        x.x - Code - simulating data/traits
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../x.x-sequence-alignment.md" class="md-nav__link">
        x.x - Code - sequence alignment
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../x.x-converting-file-formats.md" class="md-nav__link">
        x.x - Code - converting file formats
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../read, write, parse, find, and clean phylip, fasta, fastq, and vcf data." class="md-nav__link">
        Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
      
      
      
        <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
          5 - Phylogenetic Inference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          5 - Phylogenetic Inference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.0 - introduction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.1 - history
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.2 - choosing a method
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../x.3 - ..." class="md-nav__link">
        None
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../x.4 - ..." class="md-nav__link">
        None
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
      
      
      
        <label class="md-nav__link" for="__nav_10" id="__nav_10_label" tabindex="0">
          6 - Inference (Parsimony)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          6 - Inference (Parsimony)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-6/6.0-fitch-parsimony/" class="md-nav__link">
        6.0 - Fitch Parsimony
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-6/6.1-fitch-multiple-traits/" class="md-nav__link">
        6.1 - Character matrices
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        6.2 - Sankoff Parsimony
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
      
      
      
        <label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex="0">
          7 - Inference (Distance-based)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_11">
          <span class="md-nav__icon md-icon"></span>
          7 - Inference (Distance-based)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.0-introduction/" class="md-nav__link">
        7.0 - Distance based trees
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.1-least-squares/" class="md-nav__link">
        7.1 - Code - Least-squares
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.2-upgma/" class="md-nav__link">
        7.2 - Code - UPGMA
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.3-neighbor-joining/" class="md-nav__link">
        7.3 - Code - Neighbor Joining
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.4-applied/" class="md-nav__link">
        7.4 - Applied examples
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-7/7.5-new-applications/" class="md-nav__link">
        7.5 - New Applications
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_12" >
      
      
      
        <label class="md-nav__link" for="__nav_12" id="__nav_12_label" tabindex="0">
          8 - Inference (Likelihood)
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_12_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_12">
          <span class="md-nav__icon md-icon"></span>
          8 - Inference (Likelihood)
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.0 - Maximum Likelihood
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.1 - Genealogies
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.2 - Sequences
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        x.3 - Inferring
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Reading and Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_13" >
      
      
      
        <label class="md-nav__link" for="__nav_13" id="__nav_13_label" tabindex="0">
          9 - Multispecies Coalescent
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_13_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_13">
          <span class="md-nav__icon md-icon"></span>
          9 - Multispecies Coalescent
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-9/9.0-intro.md" class="md-nav__link">
        9.0 - Species trees
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-9/9.1-likelihood.md" class="md-nav__link">
        9.1 - Coalescent likelihood
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-9/9.2-genealogical.md" class="md-nav__link">
        9.2 - Genealogical thinking
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-9/9.2-genetics.md" class="md-nav__link">
        9.3 - Genetic thinking
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../chapter-9/9.3-MSC.md" class="md-nav__link">
        9.4 - MSC likelihood
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Reading and Exercises
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#learning-objectives" class="md-nav__link">
    Learning objectives
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#caching-traversals" class="md-nav__link">
    Caching Traversals
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trees-versus-nodes" class="md-nav__link">
    Trees versus Nodes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree-class" class="md-nav__link">
    Tree Class
  </a>
  
    <nav class="md-nav" aria-label="Tree Class">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#indexable-class" class="md-nav__link">
    Indexable class
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterable-class" class="md-nav__link">
    Iterable class
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree-class-advanced" class="md-nav__link">
    Tree Class (Advanced)
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  



<h1 id="the-toytree-class">The ToyTree class<a class="headerlink" href="#the-toytree-class" title="Permanent link">&para;</a></h1>
<p>In the last lesson we developed a <code>Node</code> class object that is similar to
the <code>toytree.Node</code> class, and which is used to represent a tree data 
structure. In this chapter we will develop another class that is closer 
in design to the <code>toytree.ToyTree</code> class, and which is used to represent
an entire tree. This will help to illuminate how to use the <code>toytree</code> library
more effectively, while also demonstrating some coding practices that can 
be useful in many other contexts.</p>
<h2 id="learning-objectives">Learning objectives<a class="headerlink" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>By the end of this chapter you will:</p>
<ol>
<li>learn about caching and measuring the speed of Python code.</li>
<li>understand the difference between the <code>toytree.Node</code> and <code>toytree.ToyTree</code> classes.</li>
<li>be able to extract Node coordinates to draw a tree from a Tree object.</li>
</ol>
<h2 id="caching-traversals">Caching Traversals<a class="headerlink" href="#caching-traversals" title="Permanent link">&para;</a></h2>
<p>Although we just learned that tree traversal algorithms are widely useful 
for working with tree data structures, I am now going to going to argue a
slightly contrary point, which is that for the purpose of writing 
super-efficient Python code, you should try to limit the use of tree 
traversals as much as possible. </p>
<p>This is to say, if a tree isn't changed in some way (e.g., by modifying the 
topology or edge lengths), then a single tree traversal can be performed to 
<em>cache</em> the information about the tree structure (e.g., a specific traversal 
order), and any subsequent operations can make use of this cached information 
rather than traversing the entire tree again. This can make code run much
faster since fetching information from a cache (e.g., a dictionary) is 
pretty much the fastest thing you can do in Python; much faster than 
traversing an entire tree. Of course, if the tree <em>does change</em> in some way
(e.g., it is re-rooted) then a tree traversal will need to be performed to 
learn the new structure and update the cached information again.</p>
<p>To make this point more clear, let's walk through an example. Let's say that
we want to access the names of every leaf Node in a tree of connected Nodes. 
In the previous chapter we wrote a function in our <code>Node</code> class that can do 
this by performing a tree traversal and yielding the names of leaf Nodes as 
they are visited. The speed of this operation is the speed of traversing the
entire tree. I'll first re-use our code from the last chapter to generate
a random tree of Nodes. </p>
<details>
<summary>Node class and get_random_tree function definitions (see last chapter)</summary>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Node instance that can connect with other Nodes to form a Tree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name: str</span>
<span class="sd">        A name string associated with a Node when printed or visualized.</span>
<span class="sd">    dist: float</span>
<span class="sd">        A float value as the distance between this Node and its parent (up)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    children: Tuple</span>
<span class="sd">        A tuple of Node instances that are descended from this Node.</span>
<span class="sd">    up: Node or None</span>
<span class="sd">        A Node that is ancestral to this Node, or None if this Node is root.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; node = Node(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; node.add_child(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(node.name, node.children)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string representation as Node(name).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if Node is a leaf (i.e., has no children).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if Node is the root (i.e., has no ancestor).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Node&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a Node as a child to this one.&quot;&quot;&quot;</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="p">(</span><span class="n">new_node</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">new_node</span>

    <span class="c1">############################################################</span>
    <span class="c1">## TRAVERSAL FUNCTIONS                                    ##</span>
    <span class="c1">############################################################</span>

    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a generator over all Nodes using a tree traversal strategy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strategy: str</span>
<span class="sd">            A traversal strategy for the order in which nodes will</span>
<span class="sd">            be visited: &#39;preorder&#39;, &#39;postorder&#39;, &#39;levelorder&#39;,</span>
<span class="sd">            &#39;inorder&#39;, or &#39;idxorder&#39;.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        preorder:</span>
<span class="sd">            Parents are visited before children. Traverses all the way</span>
<span class="sd">            down each left subtree before backtracking to right subtree.</span>
<span class="sd">        postorder:</span>
<span class="sd">            Children are visited before parents. The left subtree is</span>
<span class="sd">            visited, then right, then the parent.</span>
<span class="sd">        levelorder:</span>
<span class="sd">            Nodes the same depth from root are visited left to</span>
<span class="sd">            right, before descending to next level.</span>
<span class="sd">        idxorder:</span>
<span class="sd">            Leaf nodes are visited left to right, followed by internal</span>
<span class="sd">            nodes in postorder traversal order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;preorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_preorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;levelorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_levelorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;postorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_postorder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;idxorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_idxorder</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;strategy </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2"> is not a supported traversal algorithm&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_traverse_preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all nodes by &#39;preorder&#39; traversal.&quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_traverse_levelorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all desdecendant nodes in levelorder.&quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_traverse_postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all descendant nodes in tip-to-root order.&quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="c1"># get node from queue and add to the output stack</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1"># add node&#39;s children to the queue</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="c1"># yield nodes in reverse order they were added to stack</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_traverse_idxorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterates over all nodes in &#39;idx&#39; order.&quot;&quot;&quot;</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">inner_stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">outer_stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>

            <span class="c1"># get node from end of the queue</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1"># if node is leaf insert to output stack ntips from right</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">outer_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># if not leaf then insert to output stack...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inner_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># add node&#39;s children to the queue</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="c1"># return nodes in reverse order they were added to stack</span>
        <span class="k">while</span> <span class="n">outer_stack</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">outer_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">inner_stack</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">inner_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1">######################################################</span>
    <span class="c1">## LEAF AND NAME RETRIEVAL                          ##</span>
    <span class="c1">######################################################</span>

    <span class="k">def</span> <span class="nf">_iter_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Generator of leaves descended from this node in</span>
<span class="sd">        idxorder.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;idxorder&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of leaf nodes descended from this node in</span>
<span class="sd">        idxorder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_leaves</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_iter_leaf_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Generator of names of Nodes descended from this</span>
<span class="sd">        node in idxorder.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_leaves</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">get_leaf_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of names of Nodes descended from this node</span>
<span class="sd">        in idxorder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_leaf_names</span><span class="p">())</span>

    <span class="c1">#################################################</span>
    <span class="c1">## NODE RELATIVE RETRIEVAL / TRAVERSAL</span>
    <span class="c1">#################################################</span>

    <span class="k">def</span> <span class="nf">_iter_sisters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Generator to iterate over sister nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">child</span>

    <span class="k">def</span> <span class="nf">get_sisters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return list of other Nodes that are children of same parent.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_sisters</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_iter_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Generator of descendant Nodes (not including self).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of descendant Nodes (not including self).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_descendants</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_iter_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Generator of Nodes on path from this node to root.&quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of Nodes on path from this node to root.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_ancestors</span><span class="p">())</span>            


<span class="k">def</span> <span class="nf">get_random_tree</span><span class="p">(</span><span class="n">ntips</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Node&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a ladder-like tree of Node objects with &#39;ntips&#39; tip Nodes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ntips: int</span>
<span class="sd">        The number of tip Nodes that must exist before the tree is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Node</span>
<span class="sd">        The root Node of the set of connected Nodes is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set random seed</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># create root Node with name=root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># store Nodes in a list that are currently tips</span>
    <span class="n">tips</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>

    <span class="c1"># add tip Nodes by splitting &#39;node&#39; into a bifurcation until ntips exist.</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntips</span><span class="p">):</span>

        <span class="c1"># randomly sample one of the current tip Nodes</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tips</span><span class="p">)</span>
        <span class="n">tips</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># create two new tips from &#39;node&#39; and add to tips list  </span>
        <span class="n">child_l</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;left</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">child_r</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;right</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tips</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">child_l</span><span class="p">,</span> <span class="n">child_r</span><span class="p">])</span>

    <span class="c1"># return root Node that now has ntips descended tip Nodes</span>
    <span class="k">return</span> <span class="n">root</span>
</code></pre></div>
</details>
<p><div class="highlight"><pre><span></span><code><span class="c1"># example: iterate over tree traversal to get names of all tip Nodes.</span>
<span class="n">root_node</span> <span class="o">=</span> <span class="n">get_random_tree</span><span class="p">(</span><span class="n">ntips</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">root_node</span><span class="o">.</span><span class="n">get_leaf_names</span><span class="p">())</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># (&#39;left5&#39;, &#39;right5&#39;, &#39;left4&#39;, &#39;right4&#39;, &#39;left6&#39;, &#39;left7&#39;, &#39;left9&#39;, &#39;right9&#39;, &#39;left8&#39;, &#39;right8&#39;)</span>
</code></pre></div></p>
<p>To measure the speed of this code we can use the <code>%%timeit</code> magic command as 
the first line of a code block in an interactive Python session (e.g., in 
jupyter). This will run the function many times iteratively and report the
average time it takes to complete. On my computer this function takes about
7 µs (microseconds).
<div class="highlight"><pre><span></span><code><span class="o">%%</span><span class="n">timeit</span>
<span class="n">root_node</span><span class="o">.</span><span class="n">get_leaf_names</span><span class="p">()</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># 7.08 µs ± 117 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)</span>
</code></pre></div></p>
<p>Now let's compare this to the speed of fetching the names of the tip Nodes 
from a cached collection. As we will learn more about soon, <code>toytree.ToyTree</code>
objects store a dictionary to cache a reference to every Node according 
to a label representing the order in which it will be visiting using the
<em>idxorder</em> traversal. In other words, it stores a dictionary that looks like
this <code>{0: Node(A), 1: Node(B), 2: Node(C), ...}</code>. This dict is stored and 
reused for many purposes that require fetching information about one or more
Nodes.</p>
<p>So let's start by creating a dictionary like this, which can be done in a 
number of ways. This example uses the builtin <code class="highlight"><span class="nb">enumerate</span></code> function, 
which returns a generator that yields tuples for each element in an iterable
where the first element is an increasing counter from 0-nitems. Explore this 
function if you are not familiar with it, because we will use 
<code class="highlight"><span class="nb">enumerate</span></code> frequently. A dict is constructed by passing this 
generator of tuples to the <code class="highlight"><span class="nb">dict</span></code> function.</p>
<p><div class="highlight"><pre><span></span><code><span class="c1"># create a dictionary to cache a reference to each Node</span>
<span class="n">idx_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">root_node</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s2">&quot;idxorder&quot;</span><span class="p">)))</span>
<span class="n">idx_dict</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># {0: Node(left5),</span>
<span class="c1">#  1: Node(right5),</span>
<span class="c1">#  2: Node(left4),</span>
<span class="c1">#  3: Node(right4),</span>
<span class="c1">#  4: Node(left6),</span>
<span class="c1">#  5: Node(left7),</span>
<span class="c1">#  6: Node(left9),</span>
<span class="c1">#  7: Node(right9),</span>
<span class="c1">#  8: Node(left8),</span>
<span class="c1">#  9: Node(right8),</span>
<span class="c1">#  10: Node(left3),</span>
<span class="c1">#  11: Node(right3),</span>
<span class="c1">#  12: Node(left1),</span>
<span class="c1">#  13: Node(right7),</span>
<span class="c1">#  14: Node(right6),</span>
<span class="c1">#  15: Node(left2),</span>
<span class="c1">#  16: Node(right2),</span>
<span class="c1">#  17: Node(right1),</span>
<span class="c1">#  18: Node(root)}</span>
</code></pre></div></p>
<p>Now let's compare how long it takes to fetch the tip Node names from this dict.
The values were stored using a reference to their order in an <em>idxorder</em> 
traversal, which we will refer to as a Node's index (<code>idx</code>). We know that for
a tree with 10 tips the idx 0-9 will be the tip Nodes, since <em>idxorder</em> is
a traversal that visits all tips before internal Nodes. Therefore, we just 
need to fetch the first 10 Nodes. As you can see below, this operation
takes only 546 ns (nanoseconds), which is equivalent to 0.546 µs, making it 
approximately 13X faster than using a traversal! That's pretty dramatic. 
The degree to which caching is faster than traversing will also increase 
very fast as the tree becomes larger, since both operations scale linearly 
with tree size.</p>
<p><div class="highlight"><pre><span></span><code><span class="o">%%</span><span class="n">timeit</span>
<span class="p">[</span><span class="n">idx_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># 546 ns ± 11.7 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</span>
</code></pre></div></p>
<h2 id="trees-versus-nodes">Trees versus Nodes<a class="headerlink" href="#trees-versus-nodes" title="Permanent link">&para;</a></h2>
<p>The significant difference between the speed of fetching Node data 
cached in a dictionary versus traversing a tree to find a specific set of
Nodes underlies the core reason why the <code>toytree</code> library uses two separate
class objects, <code>toytree.Node</code> and <code>toytree.ToyTree</code>. The former represents 
individual Nodes, just as we have been working with until now. The <code>ToyTree</code> 
class, by contrast, is intended to represent an entire tree (a fixed 
collection of Node objects), referenced by its root <code>Node</code>. When a <code>ToyTree</code> 
is initialized it creates a cached dictionary to store references to the Nodes
in <em>idxorder</em>, and it reuses this cached dictionary to perform many tree-based
operations much faster than could be done by traversal with <code>Node</code> objects. 
Thus, as you will see, the <code>ToyTree</code> class contains many more functions than 
the <code>Node</code> class for working with trees, to fetch tree info, perform 
statistical analyses, create tree drawings, and modify the tree data 
structure (by editing Node attributes and then updating the cached Node info).
This distinction between <code>Node</code> and <code>ToyTree</code> class objects was a design 
decision for making code faster and more organized, and to separate code that
is used to build trees (Nodes) from code that is used to study trees (Trees).</p>
<h2 id="tree-class">Tree Class<a class="headerlink" href="#tree-class" title="Permanent link">&para;</a></h2>
<p>To better understand this, we will walk through the development of a simple
<code>Tree</code> class object in this tutorial that is similar to <code>toytree.ToyTree</code>, 
just like our <code>Node</code> is analagous to <code>toytree.Node</code>. </p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>

<span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Tree is a collection of Nodes with cached traversal data.</span>

<span class="sd">    A Tree is initialized from a root Node, where upon it will perform a</span>
<span class="sd">    tree traversal to cache Node data and store the idxorder traversal. </span>
<span class="sd">    This cache will be auto-updated if the tree topology is changed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    treenode: Node</span>
<span class="sd">        The root Node of a tree data structure of Nodes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nnodes: int</span>
<span class="sd">        The number of total Nodes in the tree.</span>
<span class="sd">    ntips: int</span>
<span class="sd">        The number of tip Nodes in the tree.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; treenode = get_random_tree(ntips=20)</span>
<span class="sd">    &gt;&gt;&gt; tree = Tree(treenode)</span>
<span class="sd">    &gt;&gt;&gt; print(tree)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treenode</span><span class="p">:</span> <span class="s2">&quot;Node&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">treenode</span> <span class="o">=</span> <span class="n">treenode</span>

        <span class="c1"># attributes to be filled: cached traversal data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntips</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># run caching of Node data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a representation of the tree as a string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;Tree ntips=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ntips</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Node&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Node by its cached idxorder label (idx)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="s2">&quot;Node&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over Nodes in idxorder.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set Tree attributes nnodes, ntips, _idx_dict, and set Node._idx.</span>

<span class="sd">        This function must be called anytime the tree structure is modified</span>
<span class="sd">        by including it at the end of a function that modifies the tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># reset values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntips</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># iterate in idxorder to set Node.idx attributes and counters</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s1">&#39;idxorder&#39;</span><span class="p">)):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ntips</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span> <span class="o">=</span> <span class="n">idx</span>
</code></pre></div>
<p>Our simple <code>Tree</code> class object has a few special class methods that we have 
not seen before. This includes the <code>__getitem__</code> and <code>__iter__</code> dunders 
which we'll discuss in a minute. But first, focus on the <code>__init__</code>. Our
<code>Tree</code> class requires a Node as an input argument, which it stores as an 
attribute called <code>.treenode</code>. It then also creates three attributes 
(<code>.nnodes</code>, <code>.ntips</code>, and <code>._idx_dict</code>) that are initially set to default 
values. Finally, at the end of <code>__init__</code> another function named 
<code>_update()</code> is called. If we follow down through the class definition
we can find this function's definition. It performs a single tree traversal
and as it iterates over Nodes it stores a reference to each in a dictionary
named <code>._idx_dict</code> (stored as a private attibute of <code>Tree</code>), and it increments
the <code>.nnodes</code> and <code>.ntips</code> values as counters. Thus, we now have a cached
dict that can be used to reference each Node, and we know how many nodes and
tips there are in the tree.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># get the root Node of a collection of Nodes</span>
<span class="n">root_node</span> <span class="o">=</span> <span class="n">get_random_tree</span><span class="p">(</span><span class="n">ntips</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>

<span class="c1"># get a Tree that stores the Node as its root.</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># &lt;Tree ntips=10&gt;</span>
</code></pre></div>
<h3 id="indexable-class">Indexable class<a class="headerlink" href="#indexable-class" title="Permanent link">&para;</a></h3>
<p>One really cool feature of having the Node traversal data cached to our 
object is that we can now fetch Nodes from the <code>_idx_dict</code> dictionary by 
using their unique key labels. Here we purposefully used the <em>idxorder</em> 
traversal because it has the feature that we know Nodes 0-ntips are the 
tips, and that the final node (nnodes) will be the root. To make our <code>Tree</code>
object even more sleek, we have added a <code>__getitem__</code> function to it, which
is a special class function in Python that allows an object to be <em>indexed</em>,
just like a dict or list. This means we can use square brackets to enter an 
index key to it. Within the <code>__getitem__</code> definition we can tell it to do
anything we want to find the value to return. Our function simply tells it
to return the value from the <code>_idx_dict</code> attribute that is paired with the 
entered key. The reason we defined the <code>_idx_dict</code> to be a private attribute
is because indexing provides a cleaner alternative method for indexing from 
this cache.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># get and print the tip Nodes</span>
<span class="nb">print</span><span class="p">([</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">ntips</span><span class="p">)])</span>

<span class="c1"># get and print the root Node</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">treenode</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>

<span class="c1"># get and print all nodes in idxorder (topogically sorted)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nnodes</span><span class="p">)])</span>

<span class="c1"># get and print all nodes in reverse idxorder (topogically sorted)</span>
<span class="nb">print</span><span class="p">([</span><span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nnodes</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

<span class="c1"># get a specific Node by its idx label</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="c1"># 18</span>
<span class="c1"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]</span>
<span class="c1"># [18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>
<span class="c1"># 5</span>
</code></pre></div>
<h3 id="iterable-class">Iterable class<a class="headerlink" href="#iterable-class" title="Permanent link">&para;</a></h3>
<p>As we saw above, iterating over cached objects in a dict is much faster than
repeating a traversal algorithm. For most purposes, our main concern is 
whether the order of Nodes is topologically sorted, meaning that parents will
come before children, or vice versa, The cached <em>idxorder</em> has this feature, 
and can be iterated over in either direction, start to end, or end to start,
to visit each Node in either topologically sorted direction. As another 
convenient design feature of our <code>Tree</code> class I have added an <code>__iter__</code> 
method, which allows an instance of this class to act as a generator. Within
this function I use a generator comprehension to return an iterator over 
all Nodes in <em>idxorder</em>. Thus, we can also iterate over the cached Nodes using
the very concise syntax below:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Iterate over cached Nodes in idxorder (faster than true traversal)</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div>
<h2 id="tree-class-advanced">Tree Class (Advanced)<a class="headerlink" href="#tree-class-advanced" title="Permanent link">&para;</a></h2>
<p>One example of this is Node heights. Calculating heights seems simple, it 
is just the sum of edge lengths from the root Node, right? Well, in an 
<strong>ultrametric tree</strong> (all tips are aligned) that would be true, however, not 
all trees are ultrametric. If tips are different distances from the root
then heights must be measured relative to the tip that is farthest from the 
root. This requires at least two iterations through the tree, one to 
calculate distances from the root, and another to set the new height values
on each Node. Not too complicated. But, as we just stated, there is no 
reason to perform two <em>traversals</em>, since we can cache an ordered reference
to Nodes after the first traversal, and then just reuse that information.</p>
<p>This is the strategy in the <code>ToyTree</code> class. In fact, from the last chapter
you may remember that <em>levelorder</em> and <em>idxorder</em> traversals require storing
Nodes in a stack and then unpacking the stack to yield them in a specified
order. Thus, this traversal actually already visits each Node twice. Therefore,
we can add some additional code to this traversal method to allow it to 
calculate and store information <em>while it is already performing this 
traversal</em>. An example of this is in the code below, where we define a
new modified version of the <code>Node</code> and <code>Tree</code> classes such that the <code>Node</code>
now has two additional attributes for storing coordinate positions
(<code>height</code> and <code>x</code>) and one for storing its traversal order (<code>idx</code>). The 
<code>Tree</code> class has a more complex <code>_update</code> function now that is used to 
update all of the Node information while it is performing the traversal.</p>
<details class="example">
<summary>Node and Tree class definitions</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  1</span>
<span class="normal">  2</span>
<span class="normal">  3</span>
<span class="normal">  4</span>
<span class="normal">  5</span>
<span class="normal">  6</span>
<span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterator</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple Node class for storing connections among Nodes.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>

        <span class="c1"># attributes to be updated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string representation as Node(name).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if Node is a leaf (i.e., has no children).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if Node is the root (i.e., has no ancestor).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Node&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a Node as a child to this one.&quot;&quot;&quot;</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">+=</span> <span class="p">(</span><span class="n">new_node</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">new_node</span>


<span class="k">class</span> <span class="nc">Tree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple Tree class that caches traversal order of connected Nodes&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treenode</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">treenode</span> <span class="o">=</span> <span class="n">treenode</span>

        <span class="c1"># attributes to be filled.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntips</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;Node&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># cache Node idxorder info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;ToyTree is iterable, returning Nodes in idx order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;ToyTree is indexable by idx label to access Nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Short object representation for toytree.core.tree.ToyTree&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;toytree.ToyTree at </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">&gt;&quot;</span>            

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set and cache Node idxorder and coordinates.</span>

<span class="sd">        idxorder traversal is used to fill the ToyTree._idx_dict to </span>
<span class="sd">        make Nodes easily indexable. While doing this it also calculates</span>
<span class="sd">        Node heights and spacing (x) and counts nnodes and ntips.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># clear depth counters used to get heights during traversal</span>
        <span class="n">depths</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">treenode</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="c1"># queue starts with root children, and stack starts with root.</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">treenode</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">inner_stack</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">treenode</span><span class="p">]</span>
        <span class="n">outer_stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># traverse left then right subtrees to fill and pull from queue</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="c1"># get node from start of queue to proceed levelorder</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="c1"># set depth of this node from the root</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span>

            <span class="c1"># if leaf add to output stack and update farthest depth</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">outer_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inner_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="c1"># add node&#39;s children to the queue (left child on end)</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

        <span class="c1"># get max_depth from root, height is measured relative to this.</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depths</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># clear idx cache and counter to be filled next</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># return nodes in reverse order they were added to stack</span>
        <span class="k">while</span> <span class="n">outer_stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">outer_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">node</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntips</span> <span class="o">=</span> <span class="n">idx</span>

        <span class="c1"># return internal nodes.</span>
        <span class="k">while</span> <span class="n">inner_stack</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">inner_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">node</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="n">depths</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>            
            <span class="n">node</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>            
            <span class="n">node</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_idx_dict</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>            
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnodes</span> <span class="o">=</span> <span class="n">idx</span>

    <span class="k">def</span> <span class="nf">get_node_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a DataFrame with Node coordinates for down-facing tree.&quot;&quot;&quot;</span>
        <span class="n">iter_coords</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a DataFrame with edges of the tree.&quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">up</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
</details>
<p>The new <code>._update</code> function of the <code>Tree</code> class is now quite a bit more
complex...</p>
<!-- 
### *Private attributes*
These are termed private or hidden because they are not intended to be 
accessed by a user. The single underscore at the beginning of their name 
indicates this; stay away. It is further exemplified within interactive 
environments, like a jupyter notebook, where using tab-completion
to view attributes and functions associated with an object *will not show
private attributes and functions* by default, unless you begin to type the
underscore. 

Why create private attributes and functions? There are two good 
reasons: (1) to only show users the code that they are intended to use; and
(2) to limit or specify how a user can modify an object.


### Node class (constrained)
Let's start by creating an example Node object that uses the `@property`
decorator, and which only defines private attribute names in the `__init__`.
Remember that all attributes of a class should be defined in the `__init__`
function. So how will a user access data for this Node is all of its 
attributes are private? The answer is to use properties, which is easiest to
do using the `@property` decorator. 

The user will now be able to see `NodeExample1.name`, which looks like an 
attribute, but is actually a property. It will return the `_name` attribute
when called, and will call the associated *setter* function if the user tries
to assign a new value to the property. This latter usage is perhaps the most
important. It provides an opportunity to intercept the value that the user
wants to assign to the property and to check it for various requirements 
before assigning it to the associated private attribute. For example, if 
a user tried to call `node.name = 3` the setter function here intercepts the
input value and converts it to a string by using the `str()` function before
assigning it to the `node._name` attribute.

<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Node1</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simplified version of toytree.Node used here for demonstration.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># non-init attributes for storing connections among Nodes   </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">Node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="s1">&#39;Node1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</code></pre></div>

So we now have an improved method for setting the name of a Node, which will
ensure that the value is always a string. What else can we use properties for?
In `toytree` we use this framework to purposefully make Node objects immutable,
meaning that do not want users to edit the attributes of Node's directly, 
for example by editing which Node is the parent of another. An example of this
would be the following:
<div class="highlight"><pre><span></span><code><span class="n">node1</span> <span class="o">=</span> <span class="n">Node1</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="n">node2</span> <span class="o">=</span> <span class="n">Node1</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>
<span class="n">node3</span> <span class="o">=</span> <span class="n">Node1</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="n">node1</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span>
</code></pre></div>

The above operation is allowed using the simple Node class that we developed 
in the previous lesson. However, this is not a good operation, since the 
references among the objects is not complete. node1 has a reference to its 
two child Nodes, however, the child nodes do did not set node1 as their 
parent (`._up` attribute). One way to restrict users from making this error
is to *only allow* them to modify .children or .up using functions that are
designed to ensure that they are set appropriately. 

<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Node2</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simplified version of toytree.Node used here for demonstration.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># non-init attributes for storing connections among Nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_up</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span>

    <span class="nd">@children</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;children&#39; attribute does not allow item assignment&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Node</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>

    <span class="nd">@up</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Node</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;up&#39; attribute does not allow item assignment&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a Node as a connected child to this Node.&quot;&quot;&quot;</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">+=</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">)</span>
</code></pre></div>

Now to assign a child the user *must* use the `add_child` function, which
ensures that when a child is added the connections are made from both parent
to child, and child to parent. If the user has an advanced understanding of 
the Node2 class they can of course work around this solution by modifying the
hidden `._up` and `_children` attributes, but in that case they know that they
are editing attributes that were purposefully not exposed to the user, and so
should not be surprised if they potentially encounter unexpected outcomes.

### Private functions
We may similarly wish to develop private functions. This is useful for 
functions that are for internal use by the developer, but are unlikely to 
be useful to users. By hiding them from the user it will present a more 
user-friendly object that directs them to use it in the best way possible.

### An immutable Node class
Have a look at the `toytree.Node` class object from the current `main` branch
of `toytree` on GitHub. You can see that it follows the principle we can 
developed above but with a few additional private attributes. Most 
importantly, this includes the `.height` attribute of a Node. 

### Unique node labels (idx)
A set of connected Nodes can only be accessed by their traversal currently,
or by data assigned to nodes, such as name attributes. We have learned how to 
use properties to limit how users assign values to a single object, but what
if we want to assign data to a Node that takes into account the data of all
other connected Nodes? An example would be assigning a unique number to 
every Node to serve as a label. ...

### The ToyTree class object
As we've discussed previously, a tree-like structure can be represented 
simply by the connections among Node objects, so what use is there in 
creating a separate Tree class object? In `toytree` this was design choice
was made because we decided there was a distinction in the intended way that
a Tree versus Node object is intended to be used. A Node stores data including
information about its direct edges, whereas a Tree stores information 
about a set of connected Nodes, and has functions meant for operating on 
them as a collection. With this in mind, we created a class object 
called `ToyTree` that is initialized with a `Node` object that represents
the root Node of a tree (whether or not the tree is rooted).

<div class="highlight"><pre><span></span><code><span class="c1"># design expectation</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ToyTree</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span>

<span class="c1"># access information about all Nodes connected to root_node</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">nnodes</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">ntips</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">))</span>

<span class="c1"># traverse Nodes in desired order</span>


<span class="c1"># edit Node attributes (returns a new tree with modified Node dists)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">set_node_data</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">200</span><span class="p">})</span>
</code></pre></div>
 -->


  




                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "navigation.tracking", "search.highlight", "search.suggest", "content.code.annotate"], "search": "../../assets/javascripts/workers/search.db81ec45.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.6df46069.min.js"></script>
      
        <script src="../../javascripts/extra.js"></script>
      
        <script src="../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>